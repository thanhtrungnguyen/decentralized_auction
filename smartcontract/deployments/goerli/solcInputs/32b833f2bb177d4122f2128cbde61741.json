{
  "language": "Solidity",
  "sources": {
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nerror Auction__InvalidRegistrationTime();\r\nerror Auction__InvalidAuctionTime();\r\nerror Auction__InvalidDuePaymentTime();\r\nerror Auction__InvalidStartAuctionTime();\r\nerror Auction__InvalidRegistrationFee();\r\nerror Auction__InvalidDepositAmount();\r\nerror Auction__InvalidStartBid();\r\nerror Auction__InvalidPriceStep();\r\nerror Auction__InvalidDatetime();\r\nerror Auction__InvalidAuctionId();\r\nerror Auction__OutOfRegistrationTime();\r\nerror Auction__RequireAmountToRegisterNotMet(string auctionId, uint256 value, uint256 requireAmountToRegister);\r\nerror Auction__OutOfAuctionTime();\r\nerror Auction__InvalidBidAmount();\r\nerror Auction__NotRegisteredBidder();\r\nerror Auction__NotExistAuctionId();\r\nerror Auction__ConfirmationTimeout();\r\nerror Auction__NotWinnerOfAuction();\r\nerror Auction__TransferFailed();\r\nerror Auction__RequireAmountToPaymentNotMet(string auctionId, uint256 requirePaymentAmount);\r\nerror Auction__NotExistAuction();\r\nerror Auction__NotOwner();\r\nerror Auction__AlreadyRegisteredBidder();\r\n\r\n/**@title Decentralized Auction\r\n * @author Nguyen Thanh Trung\r\n * @notice This contract is for Decentralized Auction Platform\r\n * @dev This implements the auctioneer job\r\n */\r\ncontract Auction {\r\n    string[] private s_auctionList;\r\n    address private immutable i_owner;\r\n    uint16 private constant CONFIRMATION_TIME = 300;\r\n    uint128 f = 34000000000000000000;\r\n    enum BidderState {\r\n        BIDING, //registered or bidding\r\n        WAITING, //top 2 bidder who is watting for top 1 confirm result\r\n        WIN, //winner\r\n        LOSE, // top 3 or lower\r\n        CANCEL, //cencel bid or auction result\r\n        PAIDBACK, //paid back deposit\r\n        PAID // payment complete\r\n    }\r\n\r\n    struct AuctionInformation {\r\n        // bytes10\r\n        uint256 startRegistrationTime;\r\n        uint256 endRegistrationTime;\r\n        uint256 startAuctionTime;\r\n        uint256 endAuctionTime;\r\n        uint256 duePaymentTime;\r\n        uint256 registrationFee;\r\n        uint256 depositAmount;\r\n        uint256 startBid;\r\n        uint256 priceStep;\r\n    }\r\n\r\n    constructor() {\r\n        i_owner = msg.sender;\r\n    }\r\n\r\n    struct BidInformation {\r\n        address bidder;\r\n        uint256 bidAmount;\r\n        BidderState bidderState;\r\n    }\r\n\r\n    event CreatedAuction(\r\n        string auctionId,\r\n        uint256 startRegistrationTime,\r\n        uint256 endRegistrationTime,\r\n        uint256 startAuctionTime,\r\n        uint256 endAuctionTime,\r\n        uint256 duePaymentTime,\r\n        uint256 registrationFee,\r\n        uint256 depositAmount,\r\n        uint256 startBid,\r\n        uint256 priceStep\r\n    );\r\n    event PlacedBid(string auctionId, address bidder, uint256 bidAmount);\r\n    event RegisteredToBid(string auctionId, address bidder, BidderState bidderState);\r\n    event ClosedAuction(string auctionId);\r\n    event CanceledAuctionResult(string auctionId, address bidder, BidderState bidderState);\r\n    event Paidback(string auctionId, address bidder);\r\n    event ClosedAuctionSucessfully(string auctionId, address bidder, uint256 paidAmount);\r\n\r\n    mapping(string => AuctionInformation) private s_auctionInformations;\r\n    mapping(string => BidInformation[]) private s_bidInformations;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != i_owner) revert Auction__NotOwner();\r\n        _;\r\n    }\r\n\r\n    modifier isVailidAuctionId(string memory auctionId) {\r\n        for (uint256 i = 0; i < s_auctionList.length; i++) {\r\n            if (keccak256(abi.encodePacked(auctionId)) == keccak256(abi.encodePacked(s_auctionList[i]))) {\r\n                revert Auction__InvalidAuctionId();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isExistAuctionId(string memory auctionId) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < s_auctionList.length; i++) {\r\n            if (keccak256(abi.encodePacked(auctionId)) != keccak256(abi.encodePacked(s_auctionList[i]))) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count == s_auctionList.length) {\r\n            revert Auction__NotExistAuctionId();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidRegistrationTime(uint256 startRegistrationTime, uint256 endRegistrationTime) {\r\n        if (startRegistrationTime < block.timestamp || startRegistrationTime >= endRegistrationTime) {\r\n            revert Auction__InvalidRegistrationTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidStartAuctionTime(uint256 endRegistrationTime, uint256 startAuctionTime) {\r\n        if (endRegistrationTime >= startAuctionTime) {\r\n            revert Auction__InvalidStartAuctionTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidAuctionTime(uint256 startAuctionTime, uint256 endAuctionTime) {\r\n        if (startAuctionTime >= endAuctionTime) {\r\n            revert Auction__InvalidAuctionTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidDuePaymentTime(uint256 endAuctionTime, uint256 duePaymentTime) {\r\n        if (endAuctionTime >= duePaymentTime) {\r\n            revert Auction__InvalidDuePaymentTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidRegistrationFee(uint256 registrationFee) {\r\n        if (registrationFee <= 0) {\r\n            revert Auction__InvalidRegistrationFee();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidDepositAmount(uint256 depositAmount) {\r\n        if (depositAmount <= 0) {\r\n            revert Auction__InvalidDepositAmount();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidStartBid(uint256 depositAmount) {\r\n        if (depositAmount <= 0) {\r\n            revert Auction__InvalidStartBid();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidPriceStep(uint256 depositAmount) {\r\n        if (depositAmount <= 0) {\r\n            revert Auction__InvalidPriceStep();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isRegistrationTime(string memory auctionId) {\r\n        if (\r\n            s_auctionInformations[auctionId].startRegistrationTime > block.timestamp ||\r\n            s_auctionInformations[auctionId].endRegistrationTime < block.timestamp\r\n        ) {\r\n            revert Auction__OutOfRegistrationTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isAuctionTime(string memory auctionId) {\r\n        if (\r\n            s_auctionInformations[auctionId].startAuctionTime > block.timestamp || s_auctionInformations[auctionId].endAuctionTime < block.timestamp\r\n        ) {\r\n            revert Auction__OutOfAuctionTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidBidAmount(string memory auctionId, uint256 bidAmount) {\r\n        if (\r\n            bidAmount < s_auctionInformations[auctionId].startBid ||\r\n            bidAmount < getHighestBidOfAuction(auctionId) + s_auctionInformations[auctionId].priceStep\r\n        ) {\r\n            revert Auction__InvalidBidAmount();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isRegisteredBidder(string memory auctionId) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (s_bidInformations[auctionId][i].bidder != msg.sender) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count == s_bidInformations[auctionId].length) {\r\n            revert Auction__NotRegisteredBidder();\r\n        }\r\n        _;\r\n    }\r\n    modifier isAlreadyRegisteredBidder(string memory auctionId) {\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (s_bidInformations[auctionId][i].bidder == msg.sender) {\r\n                revert Auction__AlreadyRegisteredBidder();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n    modifier isConfirmationTime(string memory auctionId) {\r\n        if (msg.sender == s_bidInformations[auctionId][getIndexOfHighestBidOfAuction(auctionId)].bidder) {\r\n            uint256 dueConfirmationTime = s_auctionInformations[auctionId].endAuctionTime + CONFIRMATION_TIME;\r\n            if (dueConfirmationTime > block.timestamp) {\r\n                revert Auction__ConfirmationTimeout();\r\n            }\r\n        }\r\n        if (msg.sender == s_bidInformations[auctionId][getIndexOfSecondWinnerOfAuction(auctionId)].bidder) {\r\n            uint256 dueConfirmationTime = s_auctionInformations[auctionId].endAuctionTime + CONFIRMATION_TIME * 2;\r\n            if (dueConfirmationTime > block.timestamp) {\r\n                revert Auction__ConfirmationTimeout();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    //check sender is winner or not\r\n    modifier isWinnerOfAuction(string memory auctionId) {\r\n        if (s_bidInformations[auctionId][getIndexOfBidder(auctionId)].bidderState != BidderState.WIN) {\r\n            revert Auction__NotWinnerOfAuction();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function isValidatedInput(\r\n        string memory auctionId, //need validate\r\n        uint256 startRegistrationTime,\r\n        uint256 endRegistrationTime,\r\n        uint256 startAuctionTime,\r\n        uint256 endAuctionTime,\r\n        uint256 duePaymentTime,\r\n        uint256 registrationFee,\r\n        uint256 depositAmount,\r\n        uint256 startBid,\r\n        uint256 priceStep\r\n    )\r\n        internal\r\n        view\r\n        isVailidAuctionId(auctionId)\r\n        isValidRegistrationTime(startRegistrationTime, endRegistrationTime)\r\n        isValidStartAuctionTime(endRegistrationTime, startAuctionTime)\r\n        isValidAuctionTime(startAuctionTime, endAuctionTime)\r\n        isValidDuePaymentTime(endAuctionTime, duePaymentTime)\r\n        isValidRegistrationFee(registrationFee)\r\n        isValidDepositAmount(depositAmount)\r\n        isValidStartBid(startBid)\r\n        isValidPriceStep(priceStep)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function createAuction(\r\n        string memory auctionId,\r\n        uint256 startRegistrationTime,\r\n        uint256 endRegistrationTime,\r\n        uint256 startAuctionTime,\r\n        uint256 endAuctionTime,\r\n        uint256 duePaymentTime,\r\n        uint256 registrationFee,\r\n        uint256 depositAmount,\r\n        uint256 startBid,\r\n        uint256 priceStep\r\n    ) external {\r\n        if (\r\n            isValidatedInput(\r\n                auctionId,\r\n                startRegistrationTime,\r\n                endRegistrationTime,\r\n                startAuctionTime,\r\n                endAuctionTime,\r\n                duePaymentTime,\r\n                registrationFee,\r\n                depositAmount,\r\n                startBid,\r\n                priceStep\r\n            )\r\n        ) {\r\n            AuctionInformation memory auction;\r\n            auction.startRegistrationTime = startRegistrationTime;\r\n            auction.endRegistrationTime = endRegistrationTime;\r\n            auction.startAuctionTime = startAuctionTime;\r\n            auction.endAuctionTime = endAuctionTime;\r\n            auction.duePaymentTime = duePaymentTime;\r\n            auction.registrationFee = registrationFee;\r\n            auction.depositAmount = depositAmount;\r\n            auction.startBid = startBid;\r\n            auction.priceStep = priceStep;\r\n            s_auctionInformations[auctionId] = auction;\r\n            s_auctionList.push(auctionId);\r\n\r\n            emit CreatedAuction(\r\n                auctionId,\r\n                startRegistrationTime,\r\n                endRegistrationTime,\r\n                startAuctionTime,\r\n                endAuctionTime,\r\n                duePaymentTime,\r\n                registrationFee,\r\n                depositAmount,\r\n                startBid,\r\n                priceStep\r\n            );\r\n        }\r\n    }\r\n\r\n    function registerToBid(string memory auctionId)\r\n        external\r\n        payable\r\n        isExistAuctionId(auctionId)\r\n        isRegistrationTime(auctionId)\r\n        isAlreadyRegisteredBidder(auctionId)\r\n    {\r\n        uint256 requireAmountToRegister = s_auctionInformations[auctionId].registrationFee + s_auctionInformations[auctionId].depositAmount;\r\n        if (msg.value != requireAmountToRegister) {\r\n            revert Auction__RequireAmountToRegisterNotMet(auctionId, msg.value, requireAmountToRegister);\r\n        }\r\n        BidInformation memory bidInformation;\r\n        bidInformation.bidder = msg.sender;\r\n        bidInformation.bidderState = BidderState.BIDING;\r\n        s_bidInformations[auctionId].push(bidInformation);\r\n        emit RegisteredToBid(auctionId, bidInformation.bidder, bidInformation.bidderState);\r\n    }\r\n\r\n    function getHighestBidOfAuction(string memory auctionId) public view returns (uint256) {\r\n        uint256 highestBid = 0;\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (s_bidInformations[auctionId][i].bidAmount > highestBid && s_bidInformations[auctionId][i].bidderState != BidderState.CANCEL) {\r\n                highestBid = s_bidInformations[auctionId][i].bidAmount;\r\n            }\r\n        }\r\n        return highestBid;\r\n    }\r\n\r\n    //get index of bidder who is sender\r\n    function getIndexOfBidder(string memory auctionId) internal view returns (uint256) {\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (s_bidInformations[auctionId][i].bidder == msg.sender) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function placeBid(string memory auctionId, uint256 bidAmount)\r\n        external\r\n        payable\r\n        isExistAuctionId(auctionId)\r\n        isAuctionTime(auctionId)\r\n        isRegisteredBidder(auctionId)\r\n        isValidBidAmount(auctionId, bidAmount)\r\n    {\r\n        s_bidInformations[auctionId][getIndexOfBidder(auctionId)].bidAmount = bidAmount;\r\n        emit PlacedBid(auctionId, msg.sender, bidAmount);\r\n    }\r\n\r\n    function getIndexOfHighestBidOfAuction(string memory auctionId) public view returns (uint256) {\r\n        uint256 highestIndex;\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (highestIndex < s_bidInformations[auctionId][i].bidAmount && s_bidInformations[auctionId][i].bidderState != BidderState.CANCEL) {\r\n                highestIndex = i;\r\n            }\r\n        }\r\n        return highestIndex;\r\n    }\r\n\r\n    function closeAuction(string memory auctionId) external isExistAuctionId(auctionId) {\r\n        uint256 index = getIndexOfHighestBidOfAuction(auctionId);\r\n        s_bidInformations[auctionId][index].bidderState = BidderState.WIN;\r\n        uint256 index2 = getIndexOfSecondWinnerOfAuction(auctionId);\r\n        s_bidInformations[auctionId][index2].bidderState = BidderState.WAITING;\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (s_bidInformations[auctionId][i].bidderState == BidderState.BIDING) {\r\n                s_bidInformations[auctionId][i].bidderState == BidderState.LOSE;\r\n            }\r\n        }\r\n        emit ClosedAuction(auctionId);\r\n    }\r\n\r\n    function cancelAuctionResult(string memory auctionId) external payable isConfirmationTime(auctionId) isWinnerOfAuction(auctionId) {\r\n        if (msg.sender == s_bidInformations[auctionId][getIndexOfHighestBidOfAuction(auctionId)].bidder) {\r\n            s_bidInformations[auctionId][getIndexOfHighestBidOfAuction(auctionId)].bidderState = BidderState.CANCEL;\r\n            s_bidInformations[auctionId][getIndexOfSecondWinnerOfAuction(auctionId)].bidderState = BidderState.WIN;\r\n        } else {\r\n            s_bidInformations[auctionId][getIndexOfSecondWinnerOfAuction(auctionId)].bidderState = BidderState.CANCEL;\r\n        }\r\n        emit CanceledAuctionResult(auctionId, msg.sender, s_bidInformations[auctionId][getIndexOfBidder(auctionId)].bidderState);\r\n    }\r\n\r\n    function getIndexOfSecondWinnerOfAuction(string memory auctionId) public returns (uint256) {\r\n        BidInformation[] storage tempBidInformation = s_bidInformations[auctionId];\r\n        uint256 index = getHighestBidOfAuction(auctionId);\r\n        require(index < tempBidInformation.length);\r\n        tempBidInformation[index] = tempBidInformation[tempBidInformation.length - 1];\r\n        tempBidInformation.pop();\r\n        uint256 highestIndex;\r\n        for (uint256 i = 0; i < tempBidInformation.length; i++) {\r\n            if (highestIndex < tempBidInformation[i].bidAmount) {\r\n                highestIndex = i;\r\n            }\r\n        }\r\n        return highestIndex;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        (bool success, ) = i_owner.call{value: address(this).balance}(\"\");\r\n        require(success);\r\n    }\r\n\r\n    function payback(string memory auctionId) internal {\r\n        uint256 depositAmount = s_auctionInformations[auctionId].depositAmount;\r\n        for (uint256 i = 0; i < s_bidInformations[auctionId].length; i++) {\r\n            if (s_bidInformations[auctionId][i].bidderState == BidderState.LOSE) {\r\n                bool success = payable(s_bidInformations[auctionId][i].bidder).send(depositAmount);\r\n                // require(success, \"Failed to send Ether\");\r\n                if (!success) {\r\n                    revert Auction__TransferFailed();\r\n                } else {\r\n                    s_bidInformations[auctionId][i].bidderState = BidderState.PAIDBACK;\r\n                    emit Paidback(auctionId, s_bidInformations[auctionId][i].bidder);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier isValidPaymentAmount(string memory auctionId) {\r\n        uint256 requirePaymentAmount = s_bidInformations[auctionId][getIndexOfBidder(auctionId)].bidAmount -\r\n            s_auctionInformations[auctionId].depositAmount;\r\n        if (msg.value != requirePaymentAmount) {\r\n            revert Auction__RequireAmountToPaymentNotMet(auctionId, requirePaymentAmount);\r\n        }\r\n        _;\r\n    }\r\n\r\n    function payment(string memory auctionId) external payable isWinnerOfAuction(auctionId) isValidPaymentAmount(auctionId) {\r\n        s_bidInformations[auctionId][getIndexOfBidder(auctionId)].bidderState = BidderState.PAID;\r\n        emit ClosedAuctionSucessfully(auctionId, msg.sender, msg.value);\r\n    }\r\n\r\n    function getListAuctionId() external view returns (string[] memory) {\r\n        return s_auctionList;\r\n    }\r\n\r\n    function getAuctionInformationById(string memory auctionId) external view isExistAuctionId(auctionId) returns (AuctionInformation memory) {\r\n        return s_auctionInformations[auctionId];\r\n    }\r\n\r\n    function getBidInformationByAuctionId(string memory auctionId) external view isExistAuctionId(auctionId) returns (BidInformation[] memory) {\r\n        return s_bidInformations[auctionId];\r\n    }\r\n\r\n    function receiver() external payable {}\r\n\r\n    function getBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getOwner() public view returns (address) {\r\n        return i_owner;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}