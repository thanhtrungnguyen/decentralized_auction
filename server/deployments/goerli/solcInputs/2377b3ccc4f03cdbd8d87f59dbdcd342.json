{
  "language": "Solidity",
  "sources": {
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nerror Auction__InvalidRegistrationTime();\r\nerror Auction__InvalidAuctionTime();\r\nerror Auction__InvalidDuePaymentTime();\r\nerror Auction__InvalidStartAuctionTime();\r\nerror Auction__InvalidRegistrationFee();\r\nerror Auction__InvalidDepositAmount();\r\nerror Auction__InvalidStartBid();\r\nerror Auction__InvalidPriceStep();\r\nerror Auction__InvalidDatetime();\r\nerror Auction__InvalidAuctionId();\r\nerror Auction__OutOfRegistrationTime();\r\nerror Auction__RequireAmountToRegisterNotMet(bytes32 auctionId, uint256 requireAmountToRegister);\r\nerror Auction__OutOfAuctionTime();\r\nerror Auction__InvalidBidAmount();\r\nerror Auction__NotRegisteredBidder();\r\nerror Auction__NotExistAuctionId();\r\nerror Auction__ConfirmationTimeout();\r\nerror Auction__NotWinnerOfAuction();\r\nerror Auction__TransferFailed();\r\nerror Auction__RequireAmountToPaymentNotMet(bytes32 auctionId, uint256 requirePaymentAmount);\r\n\r\n/**@title Decentralized Auction\r\n * @author Nguyen Thanh Trung\r\n * @notice This contract is for Decentralized Auction Platform\r\n * @dev This implements the auctioneer job\r\n */\r\ncontract Auction {\r\n    bytes32[] private s_auctionList;\r\n    uint16 private constant CONFIRMATION_TIME = 300;\r\n    enum BidderState {\r\n        BIDING, //registered or bidding\r\n        WAITING, //top 2 bidder who is watting for top 1 confirm result\r\n        WIN, //winner\r\n        LOSE, // top 3 or lower\r\n        CANCEL, //cencel bid or auction result\r\n        WITHDEW, //paid back deposit\r\n        PAID // payment complete\r\n    }\r\n\r\n    struct AuctionInformation {\r\n        // bytes10\r\n        uint256 startRegistrationTime;\r\n        uint256 endRegistrationTime;\r\n        uint256 startAuctionTime;\r\n        uint256 endAuctionTime;\r\n        uint256 duePaymentTime;\r\n        uint256 registrationFee;\r\n        uint256 depositAmount;\r\n        uint256 startBid;\r\n        uint256 priceStep;\r\n    }\r\n\r\n    struct BidInformation {\r\n        address bidder;\r\n        uint256 bidAmount;\r\n        BidderState bidderState;\r\n    }\r\n\r\n    event CreatedAuction(\r\n        bytes32 auctionId,\r\n        uint256 startRegistrationTime,\r\n        uint256 endRegistrationTime,\r\n        uint256 startAuctionTime,\r\n        uint256 endAuctionTime,\r\n        uint256 duePaymentTime,\r\n        uint256 registrationFee,\r\n        uint256 depositAmount,\r\n        uint256 startBid,\r\n        uint256 priceStep\r\n    );\r\n    event PlacedBid(bytes32 auctionId, address bidder, uint256 bidAmount);\r\n    event RegisteredToBid(bytes32 auctionId, address bidder, BidderState bidderState);\r\n    event ClosedAuction(bytes32 auctionId);\r\n    event CanceledAuctionResult(bytes32 auctionId, address bidder, BidderState bidderState);\r\n    event Withdrew(bytes32 auctionId, address bidder);\r\n    event ClosedAuctionSucessfully(bytes32 auctionId, address bidder, uint256 paidAmount);\r\n    event TestDB(uint256 k);\r\n\r\n    mapping(bytes32 => AuctionInformation) private s_AuctionInformations;\r\n    mapping(bytes32 => BidInformation[]) private s_BidInformations;\r\n\r\n    modifier isVailidAuctionId(bytes32 auctionId) {\r\n        for (uint256 i = 0; i < s_auctionList.length; i++) {\r\n            if (auctionId == s_auctionList[i]) {\r\n                revert Auction__InvalidAuctionId();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isExistAuctionId(bytes32 auctionId) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < s_auctionList.length; i++) {\r\n            if (auctionId != s_auctionList[i]) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count == s_auctionList.length) {\r\n            revert Auction__NotExistAuctionId();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidRegistrationTime(uint256 startRegistrationTime, uint256 endRegistrationTime) {\r\n        if (\r\n            startRegistrationTime < block.timestamp ||\r\n            // block.timestamp > endRegistrationTime ||\r\n            startRegistrationTime >= endRegistrationTime\r\n        ) {\r\n            revert Auction__InvalidRegistrationTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidStartAuctionTime(uint256 endRegistrationTime, uint256 startAuctionTime) {\r\n        if (endRegistrationTime >= startAuctionTime) {\r\n            revert Auction__InvalidStartAuctionTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidAuctionTime(uint256 startAuctionTime, uint256 endAuctionTime) {\r\n        if (startAuctionTime >= endAuctionTime) {\r\n            revert Auction__InvalidAuctionTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidDuePaymentTime(uint256 endAuctionTime, uint256 duePaymentTime) {\r\n        if (endAuctionTime >= duePaymentTime) {\r\n            revert Auction__InvalidDuePaymentTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidRegistrationFee(uint256 registrationFee) {\r\n        if (registrationFee <= 0) {\r\n            revert Auction__InvalidRegistrationFee();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidDepositAmount(uint256 depositAmount) {\r\n        if (depositAmount <= 0) {\r\n            revert Auction__InvalidDepositAmount();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidStartBid(uint256 depositAmount) {\r\n        if (depositAmount <= 0) {\r\n            revert Auction__InvalidStartBid();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidPriceStep(uint256 depositAmount) {\r\n        if (depositAmount <= 0) {\r\n            revert Auction__InvalidPriceStep();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isAuctionExist(bytes32 auctionId) {\r\n        uint256 count;\r\n        for (uint256 i = 0; i < s_auctionList.length; i++) {\r\n            count++;\r\n        }\r\n        if (count == s_auctionList.length) {\r\n            revert Auction__InvalidAuctionId();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isRegistrationTime(bytes32 auctionId) {\r\n        if (\r\n            s_AuctionInformations[auctionId].startRegistrationTime < block.timestamp ||\r\n            s_AuctionInformations[auctionId].endRegistrationTime > block.timestamp\r\n        ) {\r\n            revert Auction__OutOfRegistrationTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isAuctionTime(bytes32 auctionId) {\r\n        if (\r\n            s_AuctionInformations[auctionId].startAuctionTime < block.timestamp || s_AuctionInformations[auctionId].endAuctionTime > block.timestamp\r\n        ) {\r\n            revert Auction__OutOfAuctionTime();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isValidBidAmount(bytes32 auctionId, uint256 bidAmount) {\r\n        if (\r\n            bidAmount < s_AuctionInformations[auctionId].depositAmount ||\r\n            bidAmount < getHightestBidOfAuction(auctionId) + s_AuctionInformations[auctionId].priceStep\r\n        ) {\r\n            revert Auction__InvalidBidAmount();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isRegisteredBidder(bytes32 auctionId) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < s_BidInformations[auctionId].length; i++) {\r\n            if (s_BidInformations[auctionId][i].bidder != msg.sender) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count == s_BidInformations[auctionId].length) {\r\n            revert Auction__NotRegisteredBidder();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isConfirmationTime(bytes32 auctionId) {\r\n        if (msg.sender == s_BidInformations[auctionId][getIndexOfHighestBidOfAuction(auctionId)].bidder) {\r\n            uint256 dueConfirmationTime = s_AuctionInformations[auctionId].endAuctionTime + CONFIRMATION_TIME;\r\n            if (dueConfirmationTime > block.timestamp) {\r\n                revert Auction__ConfirmationTimeout();\r\n            }\r\n        }\r\n        if (msg.sender == s_BidInformations[auctionId][getIndexOfSecondWinnerOfAuction(auctionId)].bidder) {\r\n            uint256 dueConfirmationTime = s_AuctionInformations[auctionId].endAuctionTime + CONFIRMATION_TIME * 2;\r\n            if (dueConfirmationTime > block.timestamp) {\r\n                revert Auction__ConfirmationTimeout();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    //check sender is winner or not\r\n    modifier isWinnerOfAuction(bytes32 auctionId) {\r\n        if (s_BidInformations[auctionId][getIndexOfBidder(auctionId)].bidderState != BidderState.WIN) {\r\n            revert Auction__NotWinnerOfAuction();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function isValidatedInput(\r\n        bytes32 auctionId, //need validate\r\n        uint256 startRegistrationTime,\r\n        uint256 endRegistrationTime,\r\n        uint256 startAuctionTime,\r\n        uint256 endAuctionTime,\r\n        uint256 duePaymentTime,\r\n        uint256 registrationFee,\r\n        uint256 depositAmount,\r\n        uint256 startBid,\r\n        uint256 priceStep\r\n    )\r\n        internal\r\n        view\r\n        isVailidAuctionId(auctionId)\r\n        isValidRegistrationTime(startRegistrationTime, endRegistrationTime)\r\n        isValidStartAuctionTime(endRegistrationTime, startAuctionTime)\r\n        isValidAuctionTime(startAuctionTime, endAuctionTime)\r\n        isValidDuePaymentTime(endAuctionTime, duePaymentTime)\r\n        isValidRegistrationFee(registrationFee)\r\n        isValidDepositAmount(depositAmount)\r\n        isValidStartBid(startBid)\r\n        isValidPriceStep(priceStep)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function createAuction(\r\n        bytes32 auctionId,\r\n        uint256 startRegistrationTime,\r\n        uint256 endRegistrationTime,\r\n        uint256 startAuctionTime,\r\n        uint256 endAuctionTime,\r\n        uint256 duePaymentTime,\r\n        uint256 registrationFee,\r\n        uint256 depositAmount,\r\n        uint256 startBid,\r\n        uint256 priceStep\r\n    ) external {\r\n        if (\r\n            isValidatedInput(\r\n                auctionId,\r\n                startRegistrationTime,\r\n                endRegistrationTime,\r\n                startAuctionTime,\r\n                endAuctionTime,\r\n                duePaymentTime,\r\n                registrationFee,\r\n                depositAmount,\r\n                startBid,\r\n                priceStep\r\n            )\r\n        ) {\r\n            AuctionInformation memory auction;\r\n            auction.startRegistrationTime = startRegistrationTime;\r\n            auction.endRegistrationTime = endRegistrationTime;\r\n            auction.startAuctionTime = startAuctionTime;\r\n            auction.endAuctionTime = endAuctionTime;\r\n            auction.duePaymentTime = duePaymentTime;\r\n            auction.registrationFee = registrationFee;\r\n            auction.depositAmount = depositAmount;\r\n            auction.startBid = startBid;\r\n            auction.priceStep = priceStep;\r\n            s_AuctionInformations[auctionId] = auction;\r\n            s_auctionList.push(auctionId);\r\n\r\n            emit CreatedAuction(\r\n                auctionId,\r\n                startRegistrationTime,\r\n                endRegistrationTime,\r\n                startAuctionTime,\r\n                endAuctionTime,\r\n                duePaymentTime,\r\n                registrationFee,\r\n                depositAmount,\r\n                startBid,\r\n                priceStep\r\n            );\r\n        }\r\n    }\r\n\r\n    function registerToBid(bytes32 auctionId) external payable isVailidAuctionId(auctionId) isRegistrationTime(auctionId) {\r\n        uint256 requireAmountToRegister = s_AuctionInformations[auctionId].registrationFee + s_AuctionInformations[auctionId].depositAmount;\r\n        if (msg.value < requireAmountToRegister) {\r\n            revert Auction__RequireAmountToRegisterNotMet(auctionId, requireAmountToRegister);\r\n        }\r\n        s_BidInformations[auctionId][s_BidInformations[auctionId].length].bidder = msg.sender;\r\n        s_BidInformations[auctionId][s_BidInformations[auctionId].length].bidderState = BidderState.BIDING;\r\n        emit RegisteredToBid(auctionId, msg.sender, s_BidInformations[auctionId][s_BidInformations[auctionId].length].bidderState);\r\n    }\r\n\r\n    function getHightestBidOfAuction(bytes32 auctionId) public view returns (uint256) {\r\n        uint256 highestBid = 0;\r\n        for (uint256 i = 0; i < s_BidInformations[auctionId].length; i++) {\r\n            if (s_BidInformations[auctionId][i].bidAmount > highestBid && s_BidInformations[auctionId][i].bidderState != BidderState.CANCEL) {\r\n                highestBid = s_BidInformations[auctionId][i].bidAmount;\r\n            }\r\n        }\r\n        return highestBid;\r\n    }\r\n\r\n    //get index of bidder who is sender\r\n    function getIndexOfBidder(bytes32 auctionId) internal view returns (uint256) {\r\n        for (uint256 i = 0; i < s_BidInformations[auctionId].length; i++) {\r\n            if (s_BidInformations[auctionId][i].bidder == msg.sender) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function placeBid(bytes32 auctionId, uint256 bidAmount)\r\n        external\r\n        payable\r\n        isAuctionExist(auctionId)\r\n        isAuctionTime(auctionId)\r\n        isRegisteredBidder(auctionId)\r\n        isValidBidAmount(auctionId, bidAmount)\r\n    {\r\n        s_BidInformations[auctionId][getIndexOfBidder(auctionId)].bidAmount = bidAmount;\r\n        emit PlacedBid(auctionId, msg.sender, bidAmount);\r\n    }\r\n\r\n    function getIndexOfHighestBidOfAuction(bytes32 auctionId) public view returns (uint256) {\r\n        uint256 highestIndex;\r\n        for (uint256 i = 0; i < s_BidInformations[auctionId].length; i++) {\r\n            if (highestIndex < s_BidInformations[auctionId][i].bidAmount && s_BidInformations[auctionId][i].bidderState != BidderState.CANCEL) {\r\n                highestIndex = i;\r\n            }\r\n        }\r\n        return highestIndex;\r\n    }\r\n\r\n    function closeAuction(bytes32 auctionId) external isExistAuctionId(auctionId) {\r\n        uint256 index = getIndexOfHighestBidOfAuction(auctionId);\r\n        s_BidInformations[auctionId][index].bidderState = BidderState.WIN;\r\n        uint256 index2 = getIndexOfSecondWinnerOfAuction(auctionId);\r\n        s_BidInformations[auctionId][index2].bidderState = BidderState.WAITING;\r\n        for (uint256 i = 0; i < s_BidInformations[auctionId].length; i++) {\r\n            if (s_BidInformations[auctionId][i].bidderState == BidderState.BIDING) {\r\n                s_BidInformations[auctionId][i].bidderState == BidderState.LOSE;\r\n            }\r\n        }\r\n        emit ClosedAuction(auctionId);\r\n    }\r\n\r\n    function cancelAuctionResult(bytes32 auctionId) external payable isConfirmationTime(auctionId) isWinnerOfAuction(auctionId) {\r\n        if (msg.sender == s_BidInformations[auctionId][getIndexOfHighestBidOfAuction(auctionId)].bidder) {\r\n            s_BidInformations[auctionId][getIndexOfHighestBidOfAuction(auctionId)].bidderState = BidderState.CANCEL;\r\n            s_BidInformations[auctionId][getIndexOfSecondWinnerOfAuction(auctionId)].bidderState = BidderState.WIN;\r\n        } else {\r\n            s_BidInformations[auctionId][getIndexOfSecondWinnerOfAuction(auctionId)].bidderState = BidderState.CANCEL;\r\n        }\r\n        emit CanceledAuctionResult(auctionId, msg.sender, s_BidInformations[auctionId][getIndexOfBidder(auctionId)].bidderState);\r\n    }\r\n\r\n    function getIndexOfSecondWinnerOfAuction(bytes32 auctionId) public returns (uint256) {\r\n        BidInformation[] storage tempBidInformation = s_BidInformations[auctionId];\r\n        uint256 index = getHightestBidOfAuction(auctionId);\r\n        require(index < tempBidInformation.length);\r\n        tempBidInformation[index] = tempBidInformation[tempBidInformation.length - 1];\r\n        tempBidInformation.pop();\r\n        uint256 highestIndex;\r\n        for (uint256 i = 0; i < tempBidInformation.length; i++) {\r\n            if (highestIndex < tempBidInformation[i].bidAmount) {\r\n                highestIndex = i;\r\n            }\r\n        }\r\n        return highestIndex;\r\n    }\r\n\r\n    function withdaw(bytes32 auctionId) internal {\r\n        uint256 depositAmount = s_AuctionInformations[auctionId].depositAmount;\r\n        for (uint256 i = 0; i < s_BidInformations[auctionId].length; i++) {\r\n            if (s_BidInformations[auctionId][i].bidderState == BidderState.LOSE) {\r\n                bool success = payable(s_BidInformations[auctionId][i].bidder).send(depositAmount);\r\n                // require(success, \"Failed to send Ether\");\r\n                if (!success) {\r\n                    revert Auction__TransferFailed();\r\n                } else {\r\n                    s_BidInformations[auctionId][i].bidderState = BidderState.WITHDEW;\r\n                    emit Withdrew(auctionId, s_BidInformations[auctionId][i].bidder);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier isValidPaymentAmount(bytes32 auctionId) {\r\n        uint256 requirePaymentAmount = s_BidInformations[auctionId][getIndexOfBidder(auctionId)].bidAmount -\r\n            s_AuctionInformations[auctionId].depositAmount;\r\n        if (msg.value != requirePaymentAmount) {\r\n            revert Auction__RequireAmountToPaymentNotMet(auctionId, requirePaymentAmount);\r\n        }\r\n        _;\r\n    }\r\n\r\n    function payment(bytes32 auctionId) external payable isWinnerOfAuction(auctionId) isValidPaymentAmount(auctionId) {\r\n        s_BidInformations[auctionId][getIndexOfBidder(auctionId)].bidderState = BidderState.PAID;\r\n        emit ClosedAuctionSucessfully(auctionId, msg.sender, msg.value);\r\n    }\r\n\r\n    function getListAuctionId() external view returns (bytes32[] memory) {\r\n        return s_auctionList;\r\n    }\r\n\r\n    function getAuctionInformationById(bytes32 auctionId) external view isExistAuctionId(auctionId) returns (AuctionInformation memory) {\r\n        return s_AuctionInformations[auctionId];\r\n    }\r\n\r\n    function getBidInformationByAuctionId(bytes32 auctionId) external view isExistAuctionId(auctionId) returns (BidInformation[] memory) {\r\n        return s_BidInformations[auctionId];\r\n    }\r\n\r\n    function testDB(uint256 k) external {\r\n        emit TestDB(k);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}